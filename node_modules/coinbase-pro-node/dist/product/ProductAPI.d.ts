import { AxiosInstance } from 'axios';
import { ISO_8601_MS_UTC, OrderSide, PaginatedData, Pagination } from '../payload/common';
import { RESTClient } from '..';
export interface Product {
    base_currency: string;
    base_increment: string;
    /** Maximum order size */
    base_max_size: string;
    /** Minimum order size */
    base_min_size: string;
    cancel_only: boolean;
    display_name: string;
    id: string;
    limit_only: boolean;
    margin_enabled: boolean;
    max_market_funds: string;
    min_market_funds: string;
    post_only: boolean;
    quote_currency: string;
    /**
     * Increment steps for min/max order size. The order price must be a multiple of this increment (i.e. if the
     * increment is 0.01, order prices of 0.001 or 0.021 would be rejected).
     */
    quote_increment: string;
    status: 'online';
    status_message: string;
    trading_disabled: boolean;
}
export interface ProductTicker {
    ask: string;
    bid: string;
    price: string;
    size: string;
    time: string;
    trade_id: number;
    volume: string;
}
export interface ProductStats {
    high: string;
    last: string;
    low: string;
    open: string;
    volume: string;
    volume_30day: string;
}
export interface Trade {
    price: string;
    side: OrderSide;
    size: string;
    time: ISO_8601_MS_UTC;
    trade_id: number;
}
/** Accepted granularity in seconds to group historic rates. */
export declare enum CandleGranularity {
    ONE_MINUTE = 60,
    FIVE_MINUTES = 300,
    FIFTEEN_MINUTES = 900,
    ONE_HOUR = 3600,
    SIX_HOURS = 21600,
    ONE_DAY = 86400
}
export interface BaseHistoricRateRequest {
    /** Desired time slice in seconds. */
    granularity: CandleGranularity;
}
export interface HistoricRateRequestWithTimeSpan extends BaseHistoricRateRequest {
    /** Opening time (ISO 8601) of last candle, i.e. "2020-04-28T23:00:00.000Z" */
    end: ISO_8601_MS_UTC;
    /** Opening time (ISO 8601) of first candle, i.e. "2020-04-28T00:00:00.000Z" */
    start: ISO_8601_MS_UTC;
}
export declare type HistoricRateRequest = BaseHistoricRateRequest | HistoricRateRequestWithTimeSpan;
export declare enum OrderBookLevel {
    ONLY_BEST_BID_AND_ASK = 1,
    TOP_50_BIDS_AND_ASKS = 2,
    FULL_ORDER_BOOK = 3
}
/** Active order price */
declare type ActiveOrderPrice = string;
/** Sum of the size of the orders at active order price. Size should not be multiplied by number of orders. */
declare type OrderSumSize = string;
/** Number of orders at active order price. */
declare type NumberOfOrders = number;
declare type OrderId = string;
/** Aggregated levels return only one size for each active order price. */
declare type AggregatedOrder = [ActiveOrderPrice, OrderSumSize, NumberOfOrders];
declare type NonAggregatedOrder = [ActiveOrderPrice, OrderSumSize, OrderId];
/**
 * Sequence numbers are increasing integer values for each product with every new message being exactly 1 sequence
 * number than the one before it. If you see a sequence number that is more than one value from the previous, it means
 * a message has been dropped. A sequence number less than one you have seen can be ignored or has arrived
 * out-of-order. In both situations you may need to perform logic to make sure your system is in the correct state.
 */
declare type SequenceNumber = number;
/** Represents only the best bid and ask. */
export interface OrderBookLevel1 {
    asks: AggregatedOrder[];
    bids: AggregatedOrder[];
    sequence: SequenceNumber;
}
/** Top 50 bids and asks (aggregated) BUT if there are not 50 then less bids and asks are returned. */
export interface OrderBookLevel2 {
    asks: AggregatedOrder[];
    bids: AggregatedOrder[];
    sequence: SequenceNumber;
}
/**
 * Full order book (non aggregated): Level 3 is only recommended for users wishing to maintain a full real-time order
 * book using the websocket stream. Abuse of Level 3 via polling will cause your access to be limited or blocked.
 */
export interface OrderBookLevel3 {
    asks: NonAggregatedOrder[];
    bids: NonAggregatedOrder[];
    sequence: SequenceNumber;
}
export declare type OrderBook = OrderBookLevel1 | OrderBookLevel2 | OrderBookLevel3;
export interface OrderBookRequestParameters {
    level: OrderBookLevel;
}
declare type Close = number;
declare type High = number;
declare type Low = number;
declare type Open = number;
declare type Volume = number;
export interface Candle {
    /** ID of base asset */
    base: string;
    /** Closing price (last trade) in the bucket interval */
    close: Close;
    /** ID of quote asset */
    counter: string;
    /** Highest price during the bucket interval */
    high: High;
    /** Lowest price during the bucket interval */
    low: Low;
    /** Opening price (first trade) in the bucket interval */
    open: Open;
    /** Bucket start time in simplified extended ISO 8601 format */
    openTimeInISO: ISO_8601_MS_UTC;
    /** Bucket start time converted to milliseconds (note: Coinbase Pro actually uses seconds) */
    openTimeInMillis: number;
    /** Product ID / Symbol */
    productId: string;
    /** Candle size in milliseconds */
    sizeInMillis: number;
    /** Volume of trading activity during the bucket interval */
    volume: Volume;
}
export declare enum ProductEvent {
    NEW_CANDLE = "ProductEvent.NEW_CANDLE"
}
export declare class ProductAPI {
    private readonly apiClient;
    private readonly restClient;
    static readonly URL: {
        PRODUCTS: string;
    };
    private watchCandlesConfig;
    constructor(apiClient: AxiosInstance, restClient: RESTClient);
    /**
     * Get historic rates for a product. Rates are returned in grouped buckets (candlesticks) based on requested
     * granularity.
     *
     * Note: The maximum number of data points for a single request is 300 candles. If your selection of start/end time
     * and granularity will result in more than 300 data points, your request will be rejected. If you wish to retrieve
     * fine granularity data over a larger time range, you will need to make multiple requests with new start/end ranges.
     *
     * @param productId - Representation for base and counter
     * @param [params] - Desired timespan
     * @see https://docs.pro.coinbase.com/#get-historic-rates
     */
    getCandles(productId: string, params: HistoricRateRequest): Promise<Candle[]>;
    /**
     * Watch a specific product ID for new candles. Candles will be emitted through the `ProductEvent.NEW_CANDLE` event.
     *
     * @param productId - Representation for base and counter
     * @param granularity - Desired candle size
     * @param lastCandleTime - Timestamp (ISO 8601) of last candle received
     * @returns Handle to stop the watch interval
     */
    watchCandles(productId: string, granularity: CandleGranularity, lastCandleTime: ISO_8601_MS_UTC): void;
    /**
     * Stop watching a specific candle interval.
     *
     * @param productId - Representation for base and counter
     * @param granularity - Desired candle size
     */
    unwatchCandles(productId: string, granularity: CandleGranularity): void;
    /**
     * Get trading details for a specified product.
     *
     * @see https://docs.pro.coinbase.com/#get-products
     */
    getProduct(productId: string): Promise<Product | undefined>;
    /**
     * Get trading details of all available products.
     *
     * @see https://docs.pro.coinbase.com/#get-products
     */
    getProducts(): Promise<Product[]>;
    /**
     * Get latest trades for a product.
     *
     * @param productId - Representation for base and counter
     * @param pagination - Pagination field
     * @see https://docs.pro.coinbase.com/#get-trades
     */
    getTrades(productId: string, pagination?: Pagination): Promise<PaginatedData<Trade>>;
    /**
     * Get a list of open orders for a product. The amount of detail shown can be customized with the level parameter.
     * By default, only the inside (i.e. best) bid and ask are returned. This is equivalent to a book depth of 1 level.
     *
     * @param productId - Representation for base and counter
     * @param params - Amount of detail
     * @see https://docs.pro.coinbase.com/#get-product-order-book
     */
    getProductOrderBook(productId: string, params?: {
        level: OrderBookLevel.ONLY_BEST_BID_AND_ASK;
    }): Promise<OrderBookLevel1>;
    getProductOrderBook(productId: string, params?: {
        level: OrderBookLevel.TOP_50_BIDS_AND_ASKS;
    }): Promise<OrderBookLevel2>;
    getProductOrderBook(productId: string, params?: {
        level: OrderBookLevel.FULL_ORDER_BOOK;
    }): Promise<OrderBookLevel3>;
    /**
     * Get latest 24 hours of movement data for a product.
     *
     * @param productId - Representation for base and counter
     * @see https://docs.pro.coinbase.com/#get-24hr-stats
     */
    getProductStats(productId: string): Promise<ProductStats>;
    /**
     * Get snapshot information about the last trade (tick), best bid/ask and 24h volume.
     *
     * @param productId - Representation for base and counter
     * @see https://docs.pro.coinbase.com/#get-product-ticker
     */
    getProductTicker(productId: string): Promise<ProductTicker>;
    private mapCandle;
    private emitCandle;
    private checkNewCandles;
    private startCandleInterval;
}
export {};
