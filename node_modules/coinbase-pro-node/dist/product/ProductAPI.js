"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductAPI = exports.ProductEvent = exports.OrderBookLevel = exports.CandleGranularity = void 0;
const CandleBucketUtil_1 = require("./CandleBucketUtil");
/** Accepted granularity in seconds to group historic rates. */
var CandleGranularity;
(function (CandleGranularity) {
    CandleGranularity[CandleGranularity["ONE_MINUTE"] = 60] = "ONE_MINUTE";
    CandleGranularity[CandleGranularity["FIVE_MINUTES"] = 300] = "FIVE_MINUTES";
    CandleGranularity[CandleGranularity["FIFTEEN_MINUTES"] = 900] = "FIFTEEN_MINUTES";
    CandleGranularity[CandleGranularity["ONE_HOUR"] = 3600] = "ONE_HOUR";
    CandleGranularity[CandleGranularity["SIX_HOURS"] = 21600] = "SIX_HOURS";
    CandleGranularity[CandleGranularity["ONE_DAY"] = 86400] = "ONE_DAY";
})(CandleGranularity = exports.CandleGranularity || (exports.CandleGranularity = {}));
var OrderBookLevel;
(function (OrderBookLevel) {
    OrderBookLevel[OrderBookLevel["ONLY_BEST_BID_AND_ASK"] = 1] = "ONLY_BEST_BID_AND_ASK";
    OrderBookLevel[OrderBookLevel["TOP_50_BIDS_AND_ASKS"] = 2] = "TOP_50_BIDS_AND_ASKS";
    OrderBookLevel[OrderBookLevel["FULL_ORDER_BOOK"] = 3] = "FULL_ORDER_BOOK";
})(OrderBookLevel = exports.OrderBookLevel || (exports.OrderBookLevel = {}));
var ProductEvent;
(function (ProductEvent) {
    ProductEvent["NEW_CANDLE"] = "ProductEvent.NEW_CANDLE";
})(ProductEvent = exports.ProductEvent || (exports.ProductEvent = {}));
class ProductAPI {
    constructor(apiClient, restClient) {
        this.apiClient = apiClient;
        this.restClient = restClient;
        this.watchCandlesConfig = {};
    }
    /**
     * Get historic rates for a product. Rates are returned in grouped buckets (candlesticks) based on requested
     * granularity.
     *
     * Note: The maximum number of data points for a single request is 300 candles. If your selection of start/end time
     * and granularity will result in more than 300 data points, your request will be rejected. If you wish to retrieve
     * fine granularity data over a larger time range, you will need to make multiple requests with new start/end ranges.
     *
     * @param productId - Representation for base and counter
     * @param [params] - Desired timespan
     * @see https://docs.pro.coinbase.com/#get-historic-rates
     */
    getCandles(productId, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = `${ProductAPI.URL.PRODUCTS}/${productId}/candles`;
            const candleSizeInMillis = params.granularity * 1000;
            const potentialParams = params;
            let rawCandles = [];
            if (potentialParams.start && potentialParams.end) {
                const fromInMillis = new Date(potentialParams.start).getTime();
                const toInMillis = new Date(potentialParams.end).getTime();
                const bucketsInMillis = CandleBucketUtil_1.CandleBucketUtil.getBucketsInMillis(fromInMillis, toInMillis, candleSizeInMillis);
                const bucketsInISO = CandleBucketUtil_1.CandleBucketUtil.getBucketsInISO(bucketsInMillis);
                for (let index = 0; index < bucketsInISO.length; index++) {
                    const bucket = bucketsInISO[index];
                    const response = yield this.apiClient.get(resource, {
                        params: {
                            end: bucket.stop,
                            granularity: params.granularity,
                            start: bucket.start,
                        },
                    });
                    rawCandles.push(...response.data);
                }
            }
            else {
                const response = yield this.apiClient.get(resource, { params });
                rawCandles = response.data;
            }
            return rawCandles
                .map(candle => this.mapCandle(candle, candleSizeInMillis, productId))
                .sort((a, b) => a.openTimeInMillis - b.openTimeInMillis);
        });
    }
    /**
     * Watch a specific product ID for new candles. Candles will be emitted through the `ProductEvent.NEW_CANDLE` event.
     *
     * @param productId - Representation for base and counter
     * @param granularity - Desired candle size
     * @param lastCandleTime - Timestamp (ISO 8601) of last candle received
     * @returns Handle to stop the watch interval
     */
    watchCandles(productId, granularity, lastCandleTime) {
        this.watchCandlesConfig[productId] = this.watchCandlesConfig[productId] || {};
        if (this.watchCandlesConfig[productId][granularity]) {
            throw new Error(`You are already watching "${productId}" with an interval of "${granularity}" seconds. Please clear this interval before creating a new one.`);
        }
        else {
            const expectedISO = CandleBucketUtil_1.CandleBucketUtil.addUnitISO(lastCandleTime, granularity, 1);
            const intervalId = this.startCandleInterval(productId, granularity);
            this.watchCandlesConfig[productId][granularity] = {
                expectedISO,
                intervalId,
            };
        }
    }
    /**
     * Stop watching a specific candle interval.
     *
     * @param productId - Representation for base and counter
     * @param granularity - Desired candle size
     */
    unwatchCandles(productId, granularity) {
        const intervalId = this.watchCandlesConfig[productId][granularity].intervalId;
        clearInterval(intervalId);
        delete this.watchCandlesConfig[productId][granularity];
        if (Object.values(this.watchCandlesConfig[productId]).length === 0) {
            delete this.watchCandlesConfig[productId];
        }
    }
    /**
     * Get trading details for a specified product.
     *
     * @see https://docs.pro.coinbase.com/#get-products
     */
    getProduct(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const products = yield this.getProducts();
            return products.find(product => product.id === productId);
        });
    }
    /**
     * Get trading details of all available products.
     *
     * @see https://docs.pro.coinbase.com/#get-products
     */
    getProducts() {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = ProductAPI.URL.PRODUCTS;
            const response = yield this.apiClient.get(resource);
            return response.data;
        });
    }
    /**
     * Get latest trades for a product.
     *
     * @param productId - Representation for base and counter
     * @param pagination - Pagination field
     * @see https://docs.pro.coinbase.com/#get-trades
     */
    getTrades(productId, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = `${ProductAPI.URL.PRODUCTS}/${productId}/trades`;
            const response = yield this.apiClient.get(resource, { params: pagination });
            return {
                data: response.data,
                pagination: {
                    after: response.headers['cb-after'],
                    before: response.headers['cb-before'],
                },
            };
        });
    }
    getProductOrderBook(productId, params = { level: OrderBookLevel.ONLY_BEST_BID_AND_ASK }) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = `${ProductAPI.URL.PRODUCTS}/${productId}/book`;
            let response;
            switch (params.level) {
                case OrderBookLevel.TOP_50_BIDS_AND_ASKS:
                    response = yield this.apiClient.get(resource, { params });
                    break;
                case OrderBookLevel.FULL_ORDER_BOOK:
                    response = yield this.apiClient.get(resource, { params });
                    break;
                default:
                    response = yield this.apiClient.get(resource, { params });
            }
            return response.data;
        });
    }
    /**
     * Get latest 24 hours of movement data for a product.
     *
     * @param productId - Representation for base and counter
     * @see https://docs.pro.coinbase.com/#get-24hr-stats
     */
    getProductStats(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = `${ProductAPI.URL.PRODUCTS}/${productId}/stats`;
            const response = yield this.apiClient.get(resource);
            return response.data;
        });
    }
    /**
     * Get snapshot information about the last trade (tick), best bid/ask and 24h volume.
     *
     * @param productId - Representation for base and counter
     * @see https://docs.pro.coinbase.com/#get-product-ticker
     */
    getProductTicker(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = `${ProductAPI.URL.PRODUCTS}/${productId}/ticker`;
            const response = yield this.apiClient.get(resource);
            return response.data;
        });
    }
    mapCandle(payload, sizeInMillis, productId) {
        const [time, low, high, open, close, volume] = payload;
        const [base, counter] = productId.split('-');
        const openTimeInMillis = time * 1000; // Map seconds to milliseconds
        return {
            base,
            close,
            counter,
            high,
            low,
            open,
            openTimeInISO: new Date(openTimeInMillis).toISOString(),
            openTimeInMillis,
            productId: productId,
            sizeInMillis,
            volume,
        };
    }
    emitCandle(productId, granularity, candle) {
        // Emit matched candle
        this.restClient.emit(ProductEvent.NEW_CANDLE, productId, granularity, candle);
        // Cache timestamp of upcoming candle
        const nextOpenTime = CandleBucketUtil_1.CandleBucketUtil.addUnitISO(candle.openTimeInMillis, granularity, 1);
        this.watchCandlesConfig[productId][granularity].expectedISO = nextOpenTime;
    }
    checkNewCandles(productId, granularity) {
        return __awaiter(this, void 0, void 0, function* () {
            const expectedTimestampISO = this.watchCandlesConfig[productId][granularity].expectedISO;
            const candles = yield this.getCandles(productId, {
                granularity,
                start: expectedTimestampISO,
            });
            // Also handles the case when candles are skipped by the exchange
            // @see https://github.com/bennycode/coinbase-pro-node/issues/306
            const matches = candles.filter(candle => candle.openTimeInMillis >= new Date(expectedTimestampISO).getTime());
            if (matches.length > 0) {
                const matchedCandle = matches[0];
                this.emitCandle(productId, granularity, matchedCandle);
            }
        });
    }
    startCandleInterval(productId, granularity) {
        // Check for new candles in the smallest candle interval possible, which is 1 minute
        const updateInterval = CandleGranularity.ONE_MINUTE * 1000;
        return global.setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield this.checkNewCandles(productId, granularity);
        }), updateInterval);
    }
}
exports.ProductAPI = ProductAPI;
ProductAPI.URL = {
    PRODUCTS: `/products`,
};
//# sourceMappingURL=ProductAPI.js.map