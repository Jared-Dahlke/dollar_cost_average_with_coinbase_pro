"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketClient = exports.WebSocketEvent = exports.WebSocketResponseType = exports.WebSocketRequestType = exports.WebSocketChannelName = void 0;
const events_1 = require("events");
const reconnecting_websocket_1 = __importDefault(require("reconnecting-websocket"));
const ws_1 = __importDefault(require("ws"));
const __1 = require("..");
var WebSocketChannelName;
(function (WebSocketChannelName) {
    /** The full channel provides real-time updates on orders and trades. These updates can be applied on to a level 3 order book snapshot to maintain an accurate and up-to-date copy of the exchange order book. */
    WebSocketChannelName["FULL"] = "full";
    /** To receive heartbeat messages for specific products once a second subscribe to the heartbeat channel. Heartbeats also include sequence numbers and last trade ids that can be used to verify no messages were missed. */
    WebSocketChannelName["HEARTBEAT"] = "heartbeat";
    /** The easiest way to keep a snapshot of the order book is to use the level2 channel. It guarantees delivery of all updates, which reduce a lot of the overhead required when consuming the full channel. */
    WebSocketChannelName["LEVEL2"] = "level2";
    /** If you are only interested in match messages you can subscribe to the matches channel. This is useful when youâ€™re consuming the remaining feed using the level 2 channel. Please note that messages can be dropped from this channel. By using the heartbeat channel you can track the last trade id and fetch trades that you missed from the REST API. */
    WebSocketChannelName["MATCHES"] = "matches";
    /** The status channel will send all products and currencies on a preset interval. */
    WebSocketChannelName["STATUS"] = "status";
    /** The ticker channel provides real-time price updates every time a match happens. It batches updates in case of cascading matches, greatly reducing bandwidth requirements. */
    WebSocketChannelName["TICKER"] = "ticker";
    /** This channel is a version of the full channel that only contains messages that include the authenticated user. Consequently, you need to be authenticated to receive any messages. */
    WebSocketChannelName["USER"] = "user";
})(WebSocketChannelName = exports.WebSocketChannelName || (exports.WebSocketChannelName = {}));
var WebSocketRequestType;
(function (WebSocketRequestType) {
    WebSocketRequestType["SUBSCRIBE"] = "subscribe";
    WebSocketRequestType["UNSUBSCRIBE"] = "unsubscribe";
})(WebSocketRequestType = exports.WebSocketRequestType || (exports.WebSocketRequestType = {}));
var WebSocketResponseType;
(function (WebSocketResponseType) {
    /** Most failure cases will cause an error message (a message with the type "error") to be emitted. */
    WebSocketResponseType["ERROR"] = "error";
    /**
     * An `activate` message is sent when a stop order is placed. When the stop is triggered the order will be placed and
     * go through the order lifecycle.
     */
    WebSocketResponseType["FULL_ACTIVATE"] = "activate";
    /**
     * An order has changed. This is the result of self-trade prevention adjusting the order size or available funds.
     * Orders can only decrease in size or funds. All `change` messages are sent anytime an order changes in size; this
     * includes resting orders (open) as well as received but not yet open. All `change` messages are also sent when a
     * new market order goes through self trade prevention and the funds for the market order have changed.
     *
     * Note: `change` messages for received but not yet open orders can be ignored when building a real-time order book.
     * The `side` field of a change message and `price` can be used as indicators for whether the change message is
     * relevant if building from a level 2 book.
     *
     * Any `change` message where the price is `null` indicates that the `change` message is for a market order. Change
     * messages for limit orders will always have a price specified.
     */
    WebSocketResponseType["FULL_CHANGE"] = "change";
    /**
     * The order is no longer on the order book. Sent for all orders for which there was a received message. This message
     * can result from an order being canceled or filled. There will be no more messages for this `order_id ` after a
     * done message. The `remaining_size` indicates how much of the order went unfilled; this will be "0" for `filled`
     * orders.
     *
     * All `market` orders will not have a `remaining_size` or `price` field as they are never on the open order book at
     * a given price.
     *
     * A `done` message will be sent for received orders which are fully filled or canceled due to self-trade prevention.
     * There will be no `open` message for such orders. All `done` messages for orders which are not on the book should
     * be ignored when maintaining a real-time order book.
     */
    WebSocketResponseType["FULL_DONE"] = "done";
    /**
     * A trade occurred between two orders. The aggressor or `taker` order is the one executing immediately after being
     * received and the `maker` order is a resting order on the book. The `side` field indicates the maker order side. If
     * the side is `sell` this indicates the maker was a sell order and the `match` is considered an up-tick. A `buy`
     * side match is a down-tick.
     */
    WebSocketResponseType["FULL_MATCH"] = "match";
    /**
     * The order is now open on the order book. This message will only be sent for orders which are not fully filled
     * immediately. The `remaining_size` will indicate how much of the order is unfilled and going on the book.
     *
     * There will be no `open` message for orders which will be filled immediately. There will be no open message for
     * market orders since they are filled immediately.
     */
    WebSocketResponseType["FULL_OPEN"] = "open";
    /**
     * A valid order has been received and is now active. This message is emitted for every single valid order as soon as
     * the matching engine receives it whether it fills immediately or not.
     *
     * The `received` message does not indicate a resting order on the order book. It simply indicates a new incoming
     * order which as been accepted by the matching engine for processing. Received orders may cause `match` message to
     * follow if they are able to begin being filled (taker behavior). Self-trade prevention may also trigger change
     * messages to follow if the order size needs to be adjusted. Orders which are not fully filled or canceled due to
     * self-trade prevention result in an `open` message and become resting orders on the order book.
     *
     * Market orders (indicated by the `order_type` field) may have an optional `funds` field which indicates how much
     * quote currency will be used to buy or sell. For example, a `funds` field of "100.00" for the "BTC-USD" product
     * would indicate a purchase of up to "100.00" USD worth of Bitcoin.
     */
    WebSocketResponseType["FULL_RECEIVED"] = "received";
    /** Heartbeats include sequence numbers and last trade ids that can be used to verify no messages were missed. */
    WebSocketResponseType["HEARTBEAT"] = "heartbeat";
    /**
     * Latest match between two orders.
     */
    WebSocketResponseType["LAST_MATCH"] = "last_match";
    /** When subscribing to the 'level2' channel it will send an initial snapshot message with the corresponding product ids, bids and asks to represent the entire order book. */
    WebSocketResponseType["LEVEL2_SNAPSHOT"] = "snapshot";
    /** Subsequent updates of a 'level2' subscription. The `time` property of `l2update` is the time of the event as recorded by our trading engine. Please note that `size` is the updated size at that price level, not a delta. A size of "0" indicates the price level can be removed. */
    WebSocketResponseType["LEVEL2_UPDATE"] = "l2update";
    /** The status channel will send all products and currencies on a preset interval. */
    WebSocketResponseType["STATUS"] = "status";
    /** Once a subscribe or unsubscribe message is received, the server will respond with a subscriptions message that lists all channels you are subscribed to. */
    WebSocketResponseType["SUBSCRIPTIONS"] = "subscriptions";
    /** The ticker channel provides real-time price updates every time a match happens. */
    WebSocketResponseType["TICKER"] = "ticker";
})(WebSocketResponseType = exports.WebSocketResponseType || (exports.WebSocketResponseType = {}));
var WebSocketEvent;
(function (WebSocketEvent) {
    WebSocketEvent["ON_CLOSE"] = "WebSocketEvent.ON_CLOSE";
    WebSocketEvent["ON_ERROR"] = "WebSocketEvent.ON_ERROR";
    WebSocketEvent["ON_MESSAGE"] = "WebSocketEvent.ON_MESSAGE";
    WebSocketEvent["ON_MESSAGE_ERROR"] = "WebSocketEvent.ON_MESSAGE_ERROR";
    WebSocketEvent["ON_MESSAGE_MATCHES"] = "WebSocketEvent.ON_MESSAGE_MATCHES";
    WebSocketEvent["ON_MESSAGE_STATUS"] = "WebSocketEvent.ON_MESSAGE_STATUS";
    WebSocketEvent["ON_MESSAGE_TICKER"] = "WebSocketEvent.ON_MESSAGE_TICKER";
    WebSocketEvent["ON_OPEN"] = "WebSocketEvent.ON_OPEN";
    WebSocketEvent["ON_SUBSCRIPTION_UPDATE"] = "WebSocketEvent.ON_SUBSCRIPTION_UPDATE";
})(WebSocketEvent = exports.WebSocketEvent || (exports.WebSocketEvent = {}));
// eslint-disable-next-line no-redeclare
class WebSocketClient extends events_1.EventEmitter {
    constructor(baseURL, signRequest) {
        super();
        this.signRequest = signRequest;
        this.baseURL = baseURL;
        this.pingTime = 10000;
        this.pongTime = this.pingTime * 1.5;
    }
    /**
     * The websocket feed is publicly available, but connections to it are rate-limited to 1 per 4 seconds per IP.
     *
     * @param reconnectOptions - Reconnect options to be used with the "reconnecting-websocket" package. Note: Options
     *   will be merged with sensible default values.
     * @see https://docs.pro.coinbase.com/#websocket-feed
     */
    connect(reconnectOptions) {
        if (this.socket) {
            throw Error(`You established already a WebSocket connection. Please call "disconnect" first before creating a new one.`);
        }
        const options = this.mergeOptions(reconnectOptions);
        this.socket = new reconnecting_websocket_1.default(this.baseURL, [], options);
        this.socket.onclose = (event) => {
            this.cleanupListener();
            this.emit(WebSocketEvent.ON_CLOSE, event);
        };
        this.socket.onerror = (event) => {
            this.cleanupListener();
            this.emit(WebSocketEvent.ON_ERROR, event);
        };
        this.socket.onmessage = (event) => {
            const response = JSON.parse(event.data);
            // Emit generic event
            this.emit(WebSocketEvent.ON_MESSAGE, response);
            // Emit specific event
            switch (response.type) {
                case WebSocketResponseType.ERROR:
                    this.emit(WebSocketEvent.ON_MESSAGE_ERROR, response);
                    break;
                case WebSocketResponseType.STATUS:
                    this.emit(WebSocketEvent.ON_MESSAGE_STATUS, response);
                    break;
                case WebSocketResponseType.SUBSCRIPTIONS:
                    this.emit(WebSocketEvent.ON_SUBSCRIPTION_UPDATE, response);
                    break;
                case WebSocketResponseType.TICKER:
                    this.emit(WebSocketEvent.ON_MESSAGE_TICKER, response);
                    break;
                case WebSocketResponseType.FULL_MATCH:
                case WebSocketResponseType.LAST_MATCH:
                    this.emit(WebSocketEvent.ON_MESSAGE_MATCHES, response);
                    break;
            }
        };
        this.socket.onopen = () => {
            var _a;
            this.emit(WebSocketEvent.ON_OPEN);
            /**
             * The 'ws' package for Node.js exposes a "ping" function, but the WebSocket API in browsers doesn't. Since
             * "coinbase-pro-node" can run in both environments (Node.js & web browsers), we have to check for the existence
             * of "ping".
             *
             * Unfortunately, the "real" WebSocket connection isn't exposed from the "reconnecting-websocket" package:
             * https://github.com/pladaria/reconnecting-websocket/pull/148
             */
            const realWebSocket = (_a = this.socket) === null || _a === void 0 ? void 0 : _a['_ws'];
            const hasPingSupport = realWebSocket && typeof realWebSocket.ping === 'function';
            this.setupHeartbeat(hasPingSupport, realWebSocket);
        };
        return this.socket;
    }
    disconnect(reason = 'Unknown reason') {
        if (this.socket) {
            this.socket.close(WebSocketClient.CLOSE_EVENT_CODE.NORMAL_CLOSURE, reason);
            this.socket = undefined;
        }
    }
    sendMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket) {
                throw new Error(`Failed to send message of type "${message.type}": You need to connect to the WebSocket first.`);
            }
            /**
             * Authentication will result in a couple of benefits:
             * 1. Messages where you're one of the parties are expanded and have more useful fields
             * 2. You will receive private messages, such as lifecycle information about stop orders you placed
             * @see https://docs.pro.coinbase.com/#subscribe
             */
            const signature = yield this.signRequest({
                httpMethod: 'GET',
                payload: '',
                requestPath: `${__1.UserAPI.URL.USERS}/self/verify`,
            });
            Object.assign(message, signature);
            this.socket.send(JSON.stringify(message));
        });
    }
    subscribe(channel) {
        this.sendMessage({
            channels: Array.isArray(channel) ? channel : [channel],
            type: WebSocketRequestType.SUBSCRIBE,
        }).finally(() => { });
    }
    unsubscribe(channel) {
        this.sendMessage({
            channels: this.mapChannels(channel),
            type: WebSocketRequestType.UNSUBSCRIBE,
        }).finally(() => { });
    }
    cleanupListener() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
        }
        if (this.pongTimeout) {
            clearTimeout(this.pongTimeout);
        }
    }
    heartbeat() {
        if (this.pongTimeout) {
            clearTimeout(this.pongTimeout);
        }
        /**
         * Enforce a reconnect when not receiving any 'pong' from Coinbase Pro in time.
         * @see https://github.com/bennycode/coinbase-pro-node/issues/374
         */
        this.pongTimeout = setTimeout(this.onPongTimeout.bind(this), this.pongTime);
    }
    onPongTimeout() {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.reconnect();
    }
    /**
     * Setup a heartbeat with ping/pong interval to avoid broken WebSocket connections:
     * @see https://github.com/websockets/ws#how-to-detect-and-close-broken-connections
     */
    setupHeartbeat(hasPingSupport, webSocket) {
        if (hasPingSupport) {
            // Subscribe to pongs
            webSocket.on('pong', this.heartbeat.bind(this));
            // Send pings
            this.pingInterval = setInterval(() => {
                webSocket.ping(() => { });
            }, this.pingTime);
        }
    }
    mergeOptions(reconnectOptions) {
        const defaultOptions = {
            WebSocket: ws_1.default,
            connectionTimeout: 2000,
            debug: false,
            maxReconnectionDelay: 4000,
            maxRetries: Infinity,
            minReconnectionDelay: 1000,
            reconnectionDelayGrowFactor: 1,
        };
        return Object.assign(Object.assign({}, defaultOptions), reconnectOptions);
    }
    mapChannels(input) {
        if (Array.isArray(input)) {
            return input;
        }
        else if (typeof input === 'string') {
            return [
                {
                    name: input,
                    product_ids: [],
                },
            ];
        }
        return [input];
    }
}
exports.WebSocketClient = WebSocketClient;
WebSocketClient.CLOSE_EVENT_CODE = {
    GOING_AWAY: 1001,
    NORMAL_CLOSURE: 1000,
    PROTOCOL_ERROR: 1002,
    UNSUPPORTED_DATA: 1003,
};
//# sourceMappingURL=WebSocketClient.js.map