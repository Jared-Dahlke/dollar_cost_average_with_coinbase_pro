"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketClient = exports.DefaultChannels = exports.SandboxWsUri = exports.WsUri = void 0;
const events_1 = require("events");
const ws_1 = __importDefault(require("ws"));
const signer_1 = require("./signer");
const public_1 = require("./public");
exports.WsUri = "wss://ws-feed.pro.coinbase.com";
exports.SandboxWsUri = "wss://ws-feed-public.sandbox.pro.coinbase.com";
exports.DefaultChannels = [
  { name: "full", product_ids: [public_1.DefaultProductID] },
  { name: "heartbeat", product_ids: [public_1.DefaultProductID] },
  { name: "status", product_ids: [public_1.DefaultProductID] },
];
class WebsocketClient extends events_1.EventEmitter {
  constructor({
    channels = exports.DefaultChannels,
    key,
    secret,
    passphrase,
    sandbox = false,
    wsUri = sandbox ? exports.SandboxWsUri : exports.WsUri,
  } = {}) {
    super();
    this.channels = channels;
    this.wsUri = wsUri;
    if (key && secret && passphrase) {
      this.#key = key;
      this.#secret = secret;
      this.#passphrase = passphrase;
    }
  }
  #key;
  #secret;
  #passphrase;
  async connect() {
    switch (this.ws?.readyState) {
      case ws_1.default.CLOSING:
      case ws_1.default.CONNECTING:
        throw new Error(`Could not connect. State: ${this.ws.readyState}`);
      case ws_1.default.OPEN:
        return;
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      this.ws = new ws_1.default(this.wsUri);
      this.ws.once("open", resolve);
      this.ws.once("error", reject);
      this.ws.on("message", (data) => {
        try {
          const message = JSON.parse(data);
          if (message.type === "error") {
            this.emit("error", message);
          } else {
            this.emit("message", message);
          }
        } catch (error) {
          this.emit("error", error);
        }
      });
      this.ws.on("open", () => {
        this.emit("open");
        this.subscribe({ channels: this.channels }).catch((error) => {
          this.emit("error", error);
        });
      });
      this.ws.on("close", () => {
        this.emit("close");
      });
      this.ws.on("error", (error) => {
        this.emit("error", error);
      });
    });
  }
  async disconnect() {
    switch (this.ws?.readyState) {
      case ws_1.default.CLOSED:
        return;
      case ws_1.default.CLOSING:
      case ws_1.default.CONNECTING:
        throw new Error(`Could not disconnect. State: ${this.ws.readyState}`);
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      if (!this.ws) {
        resolve();
      } else {
        this.ws.once("error", reject);
        this.ws.once("close", resolve);
        this.ws.close();
      }
    });
  }
  async subscribe(params) {
    await this.send({ ...params, type: "subscribe" });
  }
  async unsubscribe(params) {
    await this.send({ ...params, type: "unsubscribe" });
  }
  async send(params) {
    const { ws } = this;
    if (!ws) {
      throw new Error("Websocket is not initialized");
    }
    const message = params;
    if (this.#key && this.#secret && this.#passphrase) {
      const timestamp = Date.now() / 1000;
      const signature = signer_1.Signer({
        timestamp,
        body: "",
        method: "GET",
        url: new URL("/users/self/verify", this.wsUri),
        key: this.#key,
        secret: this.#secret,
        passphrase: this.#passphrase,
      });
      message.key = signature["CB-ACCESS-KEY"];
      message.signature = signature["CB-ACCESS-SIGN"];
      message.timestamp = signature["CB-ACCESS-TIMESTAMP"];
      message.passphrase = signature["CB-ACCESS-PASSPHRASE"];
    }
    const data = JSON.stringify(message);
    await new Promise((resolve, reject) => {
      ws.send(data, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
}
exports.WebsocketClient = WebsocketClient;
