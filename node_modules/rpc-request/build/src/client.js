"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchClient = exports.DefaultTransform = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const error_1 = require("./error");
exports.DefaultTransform = "raw";
class FetchClient {
  constructor(
    fetchOptions = {},
    { rejectNotOk = true, transform = exports.DefaultTransform, baseUrl } = {}
  ) {
    const headers = new node_fetch_1.default.Headers(fetchOptions.headers);
    this.#fetchOptions = { ...fetchOptions, headers };
    this.#clientOptions = { rejectNotOk, baseUrl, transform };
  }
  #fetchOptions;
  #clientOptions;
  get fetchOptions() {
    return this.#fetchOptions;
  }
  set fetchOptions(options) {
    this.#fetchOptions = FetchClient.mergeFetchOptions(
      this.#fetchOptions,
      options
    );
  }
  get(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "GET" });
  }
  head(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "HEAD" });
  }
  post(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "POST" });
  }
  put(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "PUT" });
  }
  delete(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "DELETE" });
  }
  options(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "OPTIONS" });
  }
  trace(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "TRACE" });
  }
  patch(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "PATCH" });
  }
  async fetch(path = "", options = {}) {
    const { baseUrl, rejectNotOk, transform } = this.#clientOptions;
    const url = new URL(path, baseUrl).toString();
    const fetchOptions = FetchClient.mergeFetchOptions(
      this.#fetchOptions,
      options
    );
    const response = await node_fetch_1.default(url, fetchOptions);
    if (rejectNotOk && !response.ok) {
      throw new error_1.UnsuccessfulFetch(response.statusText, response);
    } else if (transform === "raw") {
      return response;
    }
    const data = await response[transform]();
    return data;
  }
  static mergeFetchOptions(
    { headers: headers1, ...rest1 },
    { headers: headers2, ...rest2 }
  ) {
    const headers = new node_fetch_1.default.Headers(headers1);
    const _headers = new node_fetch_1.default.Headers(headers2);
    for (const [key, value] of _headers) {
      headers.set(key, value);
    }
    return { ...rest1, ...rest2, headers };
  }
}
exports.FetchClient = FetchClient;
exports.default = FetchClient;
